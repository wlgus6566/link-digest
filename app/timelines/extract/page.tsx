"use client";

import React from "react";
import { useState, useEffect } from "react";
import { useSearchParams, useRouter } from "next/navigation";
import Link from "next/link";
import Image from "next/image";
import { Header } from "@/components/Header";
import { TimelineAccordion } from "@/components/timeline/TimelineAccordion";
import type { TimelineGroup } from "@/lib/utils/youtube";
import { getVideoId } from "@/lib/utils/client-youtube";
import BottomNav from "@/components/bottom-nav";
import {
  Loader2,
  ArrowLeft,
  Bookmark,
  Share2,
  BookmarkCheck,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { motion, AnimatePresence } from "framer-motion";
import { SimpleToast } from "@/components/ui/toast";
import { MemoPopup } from "@/components/ui/memo-popup";
import { createClient } from "@/lib/supabase/client";

interface YouTubeVideoInfo {
  title?: string;
  channelTitle?: string;
  publishedAt?: string;
  viewCount?: string;
  channelId?: string;
}

interface BookmarkItem {
  id: string;
  seconds: number;
  text: string;
  timestamp: number;
  memo?: string;
}

export default function TimelineExtractPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const youtubeLink = searchParams.get("url") || "";

  const [loading, setLoading] = useState(true);
  const [videoId, setVideoId] = useState<string | null>(null);
  const [timelineData, setTimelineData] = useState<TimelineGroup[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [videoInfo, setVideoInfo] = useState<YouTubeVideoInfo | null>(null);
  const [bookmarkedItems, setBookmarkedItems] = useState<
    Record<string, BookmarkItem>
  >({});
  const [showToast, setShowToast] = useState(false);
  const [toastMessage, setToastMessage] = useState("");
  const [showMemoPopup, setShowMemoPopup] = useState(false);
  const [currentBookmarkId, setCurrentBookmarkId] = useState<string | null>(
    null
  );
  const [isAuthenticated, setIsAuthenticated] = useState<boolean | null>(null);

  // ÏÇ¨Ïö©Ïûê Ïù∏Ï¶ù ÏÉÅÌÉú ÌôïÏù∏
  useEffect(() => {
    const checkAuth = async () => {
      try {
        const supabase = createClient();
        const { data: sessionData } = await supabase.auth.getSession();
        setIsAuthenticated(!!sessionData.session);
      } catch (error) {
        console.error("Ïù∏Ï¶ù ÏÉÅÌÉú ÌôïÏù∏ Ïò§Î•ò:", error);
        setIsAuthenticated(false);
      }
    };

    checkAuth();
  }, []);

  // URL ÌååÎùºÎØ∏ÌÑ∞ÏóêÏÑú YouTube ÎßÅÌÅ¨ Ï≤òÎ¶¨
  useEffect(() => {
    if (!youtubeLink) {
      setError("YouTube ÎßÅÌÅ¨Í∞Ä Ï†úÍ≥µÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§");
      setLoading(false);
      return;
    }

    const extractedVideoId = getVideoId(youtubeLink);
    if (!extractedVideoId) {
      setError("Ïò¨Î∞îÎ•∏ YouTube ÎßÅÌÅ¨Í∞Ä ÏïÑÎãôÎãàÎã§");
      setLoading(false);
      return;
    }

    setVideoId(extractedVideoId);
    extractTimeline(extractedVideoId);
  }, [youtubeLink]);

  // ÌÉÄÏûÑÎùºÏù∏ Ï∂îÏ∂ú Ìï®Ïàò
  const extractTimeline = async (videoId: string) => {
    setLoading(true);

    try {
      // API Ìò∏Ï∂ú
      const response = await fetch(`/api/extract-timeline?videoId=${videoId}`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
        },
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || "ÌÉÄÏûÑÎùºÏù∏ Ï∂îÏ∂úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§");
      }

      // ÌÉÄÏûÑÎùºÏù∏ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
      setTimelineData(data.timeline || []);
      setVideoInfo(data.videoInfo || null);

      // Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóê Ï†ÄÏû•
      const timelineKey = `timeline_extracted_${videoId}`;
      localStorage.setItem(timelineKey, JSON.stringify(data.timeline || []));

      // Î∂ÅÎßàÌÅ¨ Îç∞Ïù¥ÌÑ∞ Î°úÎìú
      const bookmarkKey = `bookmarks_timeline_extracted_${videoId}`;
      const storedBookmarks = localStorage.getItem(bookmarkKey);
      if (storedBookmarks) {
        setBookmarkedItems(JSON.parse(storedBookmarks));
      } else {
        setBookmarkedItems({});
      }
    } catch (error) {
      console.error("ÌÉÄÏûÑÎùºÏù∏ Ï∂îÏ∂ú Ïò§Î•ò:", error);
      setError(
        error instanceof Error ? error.message : "ÌÉÄÏûÑÎùºÏù∏ Ï∂îÏ∂úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§"
      );
    } finally {
      setLoading(false);
    }
  };

  // Î∂ÅÎßàÌÅ¨ Ï≤òÎ¶¨ Ìï®Ïàò
  const handleBookmark = async (id: string, seconds: number, text: string) => {
    if (!videoId) return;

    const bookmarkKey = `bookmarks_timeline_extracted_${videoId}`;
    let newBookmarkedItems = { ...bookmarkedItems };

    if (newBookmarkedItems[id]) {
      // Î∂ÅÎßàÌÅ¨ Ï†úÍ±∞
      delete newBookmarkedItems[id];
      setToastMessage("ÌÉÄÏûÑÎùºÏù∏ÏóêÏÑú Ï†úÍ±∞ÎêòÏóàÏñ¥Ïöî.");
      setCurrentBookmarkId(null);

      // ÏÑúÎ≤ÑÏóêÏÑúÎèÑ Î∂ÅÎßàÌÅ¨ ÏÇ≠Ï†ú (Î°úÍ∑∏Ïù∏Îêú Í≤ΩÏö∞)
      if (isAuthenticated) {
        try {
          const response = await fetch(
            `/api/timeline-bookmarks?timeline_id=${id}&digest_id=${videoId}`,
            {
              method: "DELETE",
              headers: {
                "Content-Type": "application/json",
              },
            }
          );

          if (!response.ok) {
            console.error("ÏÑúÎ≤Ñ Î∂ÅÎßàÌÅ¨ ÏÇ≠Ï†ú Ïò§Î•ò:", await response.json());
          }
        } catch (error) {
          console.error("ÏÑúÎ≤Ñ Î∂ÅÎßàÌÅ¨ ÏÇ≠Ï†ú ÏöîÏ≤≠ Ïã§Ìå®:", error);
        }
      }
    } else {
      // Î∂ÅÎßàÌÅ¨ Ï∂îÍ∞Ä
      newBookmarkedItems[id] = {
        id,
        seconds,
        text,
        timestamp: Date.now(),
      };
      setToastMessage("üîñ ÌÉÄÏûÑÎùºÏù∏Ïóê Ï†ÄÏû•ÌñàÏñ¥Ïöî!");
      setCurrentBookmarkId(id);

      // ÏÑúÎ≤ÑÏóêÎèÑ Î∂ÅÎßàÌÅ¨ Ï†ÄÏû• (Î°úÍ∑∏Ïù∏Îêú Í≤ΩÏö∞)
      if (isAuthenticated) {
        try {
          const response = await fetch("/api/timeline-bookmarks", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              digest_id: Number(videoId),
              timeline_id: id,
              seconds: seconds,
              text: text,
            }),
          });

          if (!response.ok) {
            console.error("ÏÑúÎ≤Ñ Î∂ÅÎßàÌÅ¨ Ï†ÄÏû• Ïò§Î•ò:", await response.json());
          }
        } catch (error) {
          console.error("ÏÑúÎ≤Ñ Î∂ÅÎßàÌÅ¨ Ï†ÄÏû• ÏöîÏ≤≠ Ïã§Ìå®:", error);
        }
      }
    }

    // Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ ÏóÖÎç∞Ïù¥Ìä∏
    setBookmarkedItems(newBookmarkedItems);
    localStorage.setItem(bookmarkKey, JSON.stringify(newBookmarkedItems));
    setShowToast(true);
  };

  // Î©îÎ™® Ï†ÄÏû• Ìï®Ïàò
  const handleSaveMemo = async (memo: string) => {
    if (!currentBookmarkId || !videoId) return;

    const bookmarkKey = `bookmarks_timeline_extracted_${videoId}`;
    let newBookmarkedItems = { ...bookmarkedItems };

    if (newBookmarkedItems[currentBookmarkId]) {
      // Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóê Î©îÎ™® Ï∂îÍ∞Ä
      newBookmarkedItems[currentBookmarkId] = {
        ...newBookmarkedItems[currentBookmarkId],
        memo,
      };

      // ÏÑúÎ≤ÑÏóêÎèÑ Î©îÎ™® Ï†ÄÏû• (Î°úÍ∑∏Ïù∏Îêú Í≤ΩÏö∞)
      if (isAuthenticated) {
        try {
          // Î∂ÅÎßàÌÅ¨ ID Í∞ÄÏ†∏Ïò§Í∏∞
          const response = await fetch(
            `/api/timeline-bookmarks?digest_id=${videoId}`,
            {
              method: "GET",
            }
          );

          if (response.ok) {
            const result = await response.json();
            const serverBookmarks = result.data || [];
            const matchingBookmark = serverBookmarks.find(
              (bm: any) => bm.timeline_id === currentBookmarkId
            );

            if (matchingBookmark) {
              // ÏÑúÎ≤ÑÏóê Î©îÎ™® ÏóÖÎç∞Ïù¥Ìä∏
              const memoResponse = await fetch(
                `/api/timeline-bookmarks/${matchingBookmark.id}/memo`,
                {
                  method: "PUT",
                  headers: {
                    "Content-Type": "application/json",
                  },
                  body: JSON.stringify({ memo }),
                }
              );

              if (!memoResponse.ok) {
                console.error(
                  "ÏÑúÎ≤Ñ Î©îÎ™® Ï†ÄÏû• Ïò§Î•ò:",
                  await memoResponse.json()
                );
              }
            } else {
              // ÏÑúÎ≤ÑÏóê Î∂ÅÎßàÌÅ¨Í∞Ä ÏóÜÏúºÎ©¥ ÏÉàÎ°ú Ï†ÄÏû•
              const saveResponse = await fetch("/api/timeline-bookmarks", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  digest_id: Number(videoId),
                  timeline_id: currentBookmarkId,
                  seconds: newBookmarkedItems[currentBookmarkId].seconds,
                  text: newBookmarkedItems[currentBookmarkId].text,
                  memo,
                }),
              });

              if (!saveResponse.ok) {
                console.error(
                  "ÏÑúÎ≤Ñ Î∂ÅÎßàÌÅ¨ Ï†ÄÏû• Ïò§Î•ò:",
                  await saveResponse.json()
                );
              }
            }
          }
        } catch (error) {
          console.error("ÏÑúÎ≤Ñ Î©îÎ™® Ï†ÄÏû• ÏöîÏ≤≠ Ïã§Ìå®:", error);
        }
      }

      setBookmarkedItems(newBookmarkedItems);
      localStorage.setItem(bookmarkKey, JSON.stringify(newBookmarkedItems));

      setToastMessage("Î©îÎ™®Í∞Ä Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.");
      setShowToast(true);
    }

    // Î©îÎ™® ÌåùÏóÖ Îã´Í∏∞
    setShowMemoPopup(false);
  };

  // ÏòÅÏÉÅ Ïû¨ÏÉù ÏúÑÏπò Ïù¥Îèô Ìï®Ïàò
  const handleSeekTo = (seconds: number) => {
    if (!videoId) return;

    // iframe Ï∞æÍ∏∞
    const iframe = document.querySelector("iframe");
    if (iframe) {
      // YouTube Player APIÎ•º ÌÜµÌï¥ ÌäπÏ†ï ÏãúÍ∞ÑÏúºÎ°ú Ïù¥Îèô
      iframe.contentWindow?.postMessage(
        JSON.stringify({
          event: "command",
          func: "seekTo",
          args: [seconds, true],
        }),
        "*"
      );
    }
  };

  // Ï°∞ÌöåÏàò Ìè¨Îß∑ Ìï®Ïàò
  const formatViewCount = (count: string | undefined): string => {
    if (!count) return "0";

    const num = Number.parseInt(count, 10);
    if (isNaN(num)) return "0";

    if (num >= 10000) {
      return `${Math.floor(num / 10000)}ÎßåÌöå`;
    } else if (num >= 1000) {
      return `${Math.floor(num / 1000)}Ï≤úÌöå`;
    }

    return `${num}Ìöå`;
  };

  // ÌÜ†Ïä§Ìä∏ Îã´Í∏∞
  const handleCloseToast = () => {
    setShowToast(false);
  };

  // Î©îÎ™® ÌåùÏóÖ Îã´Í∏∞
  const handleCloseMemoPopup = () => {
    setShowMemoPopup(false);
    setCurrentBookmarkId(null);
  };

  if (error) {
    return (
      <div className="flex flex-col min-h-screen">
        <Header title="ÌÉÄÏûÑÎùºÏù∏ Ï∂îÏ∂ú" backUrl="/timelines" />
        <main className="flex-1 container px-5 py-8 flex items-center justify-center">
          <div className="max-w-sm w-full bg-white p-8 space-y-6 text-center rounded-xl border border-border-line shadow-sm">
            <div className="w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mx-auto border border-red-500/30">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                className="h-8 w-8 text-red-500"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M6 18L18 6M6 6l12 12"
                />
              </svg>
            </div>
            <h1 className="text-xl font-bold text-neutral-dark">
              ÌÉÄÏûÑÎùºÏù∏ Ï∂îÏ∂ú Ïã§Ìå®
            </h1>
            <p className="text-neutral-medium">{error}</p>
            <Button
              onClick={() => router.push("/timelines")}
              className="bg-primary-color hover:bg-primary-color/90 text-white"
            >
              ÎèåÏïÑÍ∞ÄÍ∏∞
            </Button>
          </div>
        </main>
        <BottomNav />
      </div>
    );
  }

  if (loading || !videoId) {
    return (
      <div className="flex flex-col min-h-screen pb-24">
        <Header title="ÌÉÄÏûÑÎùºÏù∏ Ï∂îÏ∂ú" backUrl="/timelines" />
        <main className="flex-1 flex items-center justify-center">
          <div className="text-center">
            <Loader2 className="h-12 w-12 animate-spin text-primary-color mx-auto mb-4" />
            <p className="text-neutral-medium">ÌÉÄÏûÑÎùºÏù∏ Ï∂îÏ∂ú Ï§ë...</p>
          </div>
        </main>
        <BottomNav />
      </div>
    );
  }

  return (
    <div className="flex flex-col min-h-screen pb-24">
      <Header
        title="ÌÉÄÏûÑÎùºÏù∏ Ï∂îÏ∂ú"
        backUrl="/timelines"
        rightElement={
          <div className="flex gap-2">
            <Button
              variant="ghost"
              size="icon"
              className="h-9 w-9 rounded-full hover:bg-primary-light"
            >
              <Share2 className="h-5 w-5 text-neutral-dark" />
            </Button>
          </div>
        }
      />

      <main className="flex-1">
        <article className="max-w-3xl mx-auto px-5 py-8">
          {/* ÏòÅÏÉÅ ÏòÅÏó≠ */}
          <motion.div
            className="mb-8 rounded-xl overflow-hidden"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.3 }}
          >
            <div className="flex flex-col bg-white rounded-xl overflow-hidden border border-border-line shadow-sm">
              <div className="relative w-full h-48 md:h-80">
                <iframe
                  src={`https://www.youtube.com/embed/${videoId}?enablejsapi=1`}
                  title={videoInfo?.title || "YouTube ÎπÑÎîîÏò§"}
                  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                  allowFullScreen
                  className="absolute top-0 left-0 w-full h-full border-0"
                />
              </div>

              {videoInfo && (
                <div className="p-4 space-y-3">
                  <h2 className="text-xl font-bold text-neutral-dark">
                    {videoInfo.title || "Ï†úÎ™© ÏóÜÏùå"}
                  </h2>

                  <div className="flex justify-between items-center">
                    <div className="flex items-center space-x-2">
                      <div className="w-9 h-9 rounded-full overflow-hidden bg-secondary-color border border-border-line">
                        {videoInfo.channelId ? (
                          <Image
                            src={`https://yt3.googleusercontent.com/ytc/${videoInfo.channelId}=s88-c-k-c0x00ffffff-no-rj`}
                            alt={videoInfo.channelTitle || "Ï±ÑÎÑê Ïù¥ÎØ∏ÏßÄ"}
                            width={36}
                            height={36}
                            className="object-cover"
                          />
                        ) : (
                          <div className="w-full h-full bg-gray-200" />
                        )}
                      </div>
                      <div>
                        <div className="font-medium text-sm text-neutral-dark">
                          {videoInfo.channelTitle || "Ï±ÑÎÑêÎ™Ö ÏóÜÏùå"}
                        </div>
                        <div className="text-xs text-neutral-medium">
                          {videoInfo.publishedAt
                            ? new Date(
                                videoInfo.publishedAt
                              ).toLocaleDateString("ko-KR", {
                                year: "numeric",
                                month: "long",
                                day: "numeric",
                              })
                            : "ÎÇ†Ïßú Ï†ïÎ≥¥ ÏóÜÏùå"}
                        </div>
                      </div>
                    </div>

                    <div className="text-sm text-neutral-medium">
                      {videoInfo.viewCount
                        ? `Ï°∞ÌöåÏàò ${formatViewCount(videoInfo.viewCount)}Ìöå`
                        : "Ï°∞ÌöåÏàò Ï†ïÎ≥¥ ÏóÜÏùå"}
                    </div>
                  </div>
                </div>
              )}
            </div>
          </motion.div>

          {/* ÌÉÄÏûÑÎùºÏù∏ ÏòÅÏó≠ */}
          {timelineData.length > 0 && (
            <motion.div
              className="mb-10"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.45 }}
            >
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-xl font-bold text-neutral-dark">
                  ÌÉÄÏûÑÎùºÏù∏
                </h2>
              </div>

              <div className="p-4 bg-gray-50 rounded-lg border border-gray-200">
                <TimelineAccordion
                  timelineGroups={timelineData}
                  onSeek={handleSeekTo}
                  bookmarkedItems={Object.keys(bookmarkedItems).reduce(
                    (acc, key) => ({
                      ...acc,
                      [key]: true,
                    }),
                    {}
                  )}
                  onBookmark={handleBookmark}
                />
              </div>
            </motion.div>
          )}
        </article>
      </main>

      <BottomNav />

      <SimpleToast
        isVisible={showToast}
        message={toastMessage}
        onClose={handleCloseToast}
        actionLabel={
          currentBookmarkId && !showMemoPopup ? "Î©îÎ™® Ï∂îÍ∞ÄÌïòÍ∏∞" : undefined
        }
        onAction={currentBookmarkId ? () => setShowMemoPopup(true) : undefined}
      />

      <MemoPopup
        isOpen={showMemoPopup}
        onClose={handleCloseMemoPopup}
        onSave={handleSaveMemo}
        initialMemo={
          currentBookmarkId
            ? bookmarkedItems[currentBookmarkId]?.memo || ""
            : ""
        }
        title="ÌÉÄÏûÑÎùºÏù∏ Î©îÎ™® Ï∂îÍ∞ÄÌïòÍ∏∞"
      />
    </div>
  );
}
